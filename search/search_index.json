{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to OpenGeo","text":"<p> A Google Earth Engine-like Python package using open-source geospatial tools </p> <p> </p> <p>OpenGeo (<code>og</code>) is a Python package designed to provide a Google Earth Engine (GEE)-like experience using open-source geospatial tools such as Xarray, Dask, STAC, and GeoPandas.</p> <p>The goal is to smooth the transition for GEE users to the open Python ecosystem by mimicking the familiar Earth Engine API while leveraging the power of local or distributed cloud computing.</p>"},{"location":"#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li>\ud83d\udd04 API Familiarity: Mimics <code>ee.Image</code>, <code>ee.ImageCollection</code>, <code>ee.FeatureCollection</code>, and <code>ee.Geometry</code> APIs</li> <li>\u26a1 Lazy Loading: Uses <code>stackstac</code> and <code>dask</code> to lazily load and process imagery from STAC catalogs</li> <li>\ud83d\udcbb Local Processing: Run your analysis locally or on a standard Dask cluster without GEE quotas</li> <li>\ud83d\udd17 Interoperability: Seamlessly integrate with <code>xarray</code>, <code>geopandas</code>, and <code>shapely</code></li> <li>\ud83c\udf0d Open Access: Focuses on community-maintained STAC APIs like Earth Search (Element84), Microsoft Planetary Computer, and more</li> <li>\ud83d\udcca Interactive Visualization: Built-in integration with Leafmap for beautiful, interactive maps</li> </ul>"},{"location":"#quick-start","title":"\ud83d\udee0\ufe0f Quick Start","text":"<pre><code>import opengeo as og\n\n# Initialize (optional, sets default STAC API)\nog.Initialize()\n\n# Create a region of interest\nroi = og.Geometry.Rectangle(77.58, 12.96, 77.60, 12.98)\n\n# Load an ImageCollection from a STAC ID (e.g., Sentinel-2 L2A)\ncol = (og.ImageCollection(\"sentinel-2-l2a\") \n       .filterDate(\"2023-01-01\", \"2023-01-31\") \n       .filterBounds(roi) \n       .select([\"red\", \"nir\"]))\n\n# Compute a composite (mean)\nimage = col.mean()\n\n# Calculate NDVI\nndvi = (image.select(\"nir\") - image.select(\"red\")) / \\\n       (image.select(\"nir\") + image.select(\"red\"))\n\n# Reduce over the region\nstats = ndvi.reduceRegion(reducer=\"mean\", geometry=roi, scale=10)\nprint(f\"Mean NDVI: {stats}\")\n</code></pre>"},{"location":"#api-comparison","title":"\ud83d\udcca API Comparison","text":"GEE OpenGeo Underlying Tech <code>ee.ImageCollection</code> <code>og.ImageCollection</code> <code>pystac_client</code> + <code>stackstac</code> <code>ee.Image</code> <code>og.Image</code> <code>xarray.DataArray</code> <code>ee.FeatureCollection</code> <code>og.FeatureCollection</code> <code>geopandas.GeoDataFrame</code> <code>ee.Geometry</code> <code>og.Geometry</code> <code>shapely.geometry</code> <code>geemap.Map</code> <code>og.Map</code> <code>leafmap.Map</code>"},{"location":"#why-opengeo","title":"\ud83c\udfaf Why OpenGeo?","text":"<p>For GEE Users</p> <ul> <li>Familiar API: Minimal code changes needed to port GEE scripts</li> <li>No Quotas: Process as much data as your hardware allows</li> <li>Full Control: Run locally or on your own cloud infrastructure</li> <li>Open Source: No vendor lock-in, fully transparent</li> </ul> <p>For Python Users</p> <ul> <li>Modern Stack: Built on Xarray, Dask, and STAC standards</li> <li>Pythonic: Integrates seamlessly with pandas, numpy, matplotlib</li> <li>Extensible: Easy to add custom functions and workflows</li> <li>Well Documented: Comprehensive guides and examples</li> </ul>"},{"location":"#getting-started","title":"\ud83d\udcda Getting Started","text":"<ul> <li> <p> Quick Installation</p> <p>Get up and running in minutes</p> <p> Installation Guide</p> </li> <li> <p> Usage Guide</p> <p>Learn the core concepts and workflows</p> <p> Usage Guide</p> </li> <li> <p> API Reference</p> <p>Detailed documentation for all classes and methods</p> <p> API Reference</p> </li> <li> <p> Examples</p> <p>Jupyter notebooks with real-world use cases</p> <p> View Examples</p> </li> </ul>"},{"location":"#example-use-cases","title":"\ud83c\udf1f Example Use Cases","text":"<ul> <li>\ud83c\udf3e Agriculture: Monitor crop health with NDVI time series</li> <li>\ud83c\udf33 Forestry: Track deforestation and forest degradation</li> <li>\ud83c\udf0a Water Resources: Map water bodies and monitor changes</li> <li>\ud83c\udfd9\ufe0f Urban Planning: Analyze urban growth and land use change</li> <li>\ud83d\udd25 Disaster Response: Assess wildfire damage and flood extent</li> <li>\ud83c\udf21\ufe0f Climate Studies: Analyze land surface temperature trends</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Whether it's:</p> <ul> <li>\ud83d\udc1b Bug reports</li> <li>\ud83d\udca1 Feature requests</li> <li>\ud83d\udcdd Documentation improvements</li> <li>\ud83d\udd27 Code contributions</li> </ul> <p>Check out our GitHub repository to get involved.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>OpenGeo is released under the MIT License. See LICENSE for details.</p>"},{"location":"#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<p>OpenGeo builds upon the excellent work of:</p> <ul> <li>Xarray - N-dimensional labeled arrays</li> <li>Dask - Parallel computing</li> <li>STAC - SpatioTemporal Asset Catalog</li> <li>GeoPandas - Geospatial data in Python</li> <li>Leafmap - Interactive mapping</li> <li>Google Earth Engine - Inspiration for the API design</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Installing OpenGeo is straightforward. We recommend using a virtual environment to manage dependencies.</p>"},{"location":"installation/#quick-install","title":"\ud83d\udce6 Quick Install","text":"From Source (Recommended)From PyPI (Coming Soon) <pre><code>git clone https://github.com/pulakeshpradhan/opengeo.git\ncd opengeo\npip install -e .\n</code></pre> <pre><code>pip install opengeo\n</code></pre>"},{"location":"installation/#standard-installation","title":"\ud83d\udd27 Standard Installation","text":""},{"location":"installation/#1-create-a-virtual-environment","title":"1. Create a Virtual Environment","text":"WindowsmacOS / Linux <pre><code>python -m venv venv\n.\\venv\\Scripts\\activate\n</code></pre> <pre><code>python -m venv venv\nsource venv/bin/activate\n</code></pre>"},{"location":"installation/#2-install-dependencies","title":"2. Install Dependencies","text":"<p>Install the core dependencies required for geospatial processing:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"installation/#3-install-opengeo","title":"3. Install OpenGeo","text":"<p>Install the package in editable mode if you are developing or just want to use the latest local version:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"installation/#dependencies","title":"\ud83d\udcda Dependencies","text":"<p>OpenGeo relies on the following key libraries:</p> Library Purpose pystac-client Searching STAC catalogs stackstac Loading STAC items into Xarray xarray N-dimensional array processing dask Lazy evaluation and parallel computing geopandas Vector data handling shapely Geometric operations leafmap Interactive visualization rioxarray Raster I/O with Xarray"},{"location":"installation/#verification","title":"\u2705 Verification","text":"<p>To verify the installation, try importing <code>opengeo</code> in a Python shell:</p> <pre><code>import opengeo as og\nprint(f\"OpenGeo version: {og.__version__}\")\n\n# Test basic functionality\nog.Initialize()\nprint(\"OpenGeo initialized successfully!\")\n</code></pre>"},{"location":"installation/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":"<p>Common Issues</p> <p>GDAL Installation Issues</p> <p>If you encounter GDAL-related errors, try installing it via conda: <pre><code>conda install -c conda-forge gdal\n</code></pre></p> <p>Memory Issues with Large Datasets</p> <p>Configure Dask to limit memory usage: <pre><code>import dask\ndask.config.set({'array.chunk-size': '128MB'})\n</code></pre></p> <p>Recommended Setup</p> <p>For the best experience, we recommend using Python 3.9-3.11 with a conda environment: <pre><code>conda create -n opengeo python=3.11\nconda activate opengeo\npip install -e .\n</code></pre></p>"},{"location":"usage/","title":"Usage Guide","text":"<p>OpenGeo is designed to feel natural to those familiar with Google Earth Engine (<code>ee</code>). This guide covers the core concepts and common workflows.</p>"},{"location":"usage/#initialization","title":"\ud83d\ude80 Initialization","text":"<p>By default, OpenGeo uses the Earth Search STAC API. You can initialize it with a custom STAC API URL if needed.</p> <pre><code>import opengeo as og\n\n# Default initialization (Earth Search)\nog.Initialize()\n\n# Custom STAC API initialization\n# og.Initialize(url=\"https://planetarycomputer.microsoft.com/api/stac/v1\")\n</code></pre> <p>Available STAC APIs</p> <p>OpenGeo supports multiple STAC catalogs:</p> <ul> <li>Earth Search (Element84) - Default</li> <li>Microsoft Planetary Computer</li> <li>USGS STAC</li> <li>NASA CMR STAC</li> <li>Any custom STAC API endpoint</li> </ul>"},{"location":"usage/#creating-geometries","title":"\ud83d\uddfa\ufe0f Creating Geometries","text":"<p>Define regions of interest using the <code>Geometry</code> class:</p> <pre><code># Rectangle (bounding box)\nroi = og.Geometry.Rectangle(xmin=77.58, ymin=12.96, xmax=77.60, ymax=12.98)\n\n# Point\npoint = og.Geometry.Point(longitude=77.59, latitude=12.97)\n\n# Polygon from coordinates\npolygon = og.Geometry.Polygon([\n    [77.58, 12.96],\n    [77.60, 12.96],\n    [77.60, 12.98],\n    [77.58, 12.98],\n    [77.58, 12.96]\n])\n</code></pre>"},{"location":"usage/#working-with-imagecollections","title":"\ud83d\udce1 Working with ImageCollections","text":"<p><code>og.ImageCollection</code> is the primary container for satellite imagery.</p>"},{"location":"usage/#loading-a-collection","title":"Loading a Collection","text":"<pre><code># Create a collection from STAC ID\ncol = og.ImageCollection(\"sentinel-2-l2a\")\n</code></pre>"},{"location":"usage/#filtering","title":"Filtering","text":"<pre><code># Filter by date range\ncol = col.filterDate(\"2023-01-01\", \"2023-06-01\")\n\n# Filter by spatial bounds\ncol = col.filterBounds(roi)\n\n# Filter by metadata (cloud cover)\ncol = col.filter(\"eo:cloud_cover &lt; 20\")\n\n# Chain filters\ncol = (og.ImageCollection(\"sentinel-2-l2a\")\n       .filterDate(\"2023-01-01\", \"2023-06-01\")\n       .filterBounds(roi)\n       .filter(\"eo:cloud_cover &lt; 20\"))\n</code></pre>"},{"location":"usage/#selecting-bands","title":"Selecting Bands","text":"<pre><code># Select specific bands\ncol = col.select([\"red\", \"green\", \"blue\", \"nir\"])\n\n# Select and rename\ncol = col.select([\"B04\", \"B08\"], [\"red\", \"nir\"])\n</code></pre>"},{"location":"usage/#working-with-images","title":"\ud83d\uddbc\ufe0f Working with Images","text":""},{"location":"usage/#compositing","title":"Compositing","text":"<pre><code># Create composites from collections\nmean_image = col.mean()\nmedian_image = col.median()\nmax_image = col.max()\nmin_image = col.min()\n</code></pre>"},{"location":"usage/#band-math","title":"Band Math","text":"<p>Perform arithmetic operations directly on <code>og.Image</code> objects:</p> <pre><code># Calculate NDVI\nimage = col.median()\nndvi = (image.select(\"nir\") - image.select(\"red\")) / \\\n       (image.select(\"nir\") + image.select(\"red\"))\n\n# Calculate EVI (Enhanced Vegetation Index)\nevi = 2.5 * ((image.select(\"nir\") - image.select(\"red\")) / \n             (image.select(\"nir\") + 6 * image.select(\"red\") - \n              7.5 * image.select(\"blue\") + 1))\n</code></pre>"},{"location":"usage/#masking","title":"Masking","text":"<pre><code># Create a mask\nmask = ndvi.gt(0.3)  # NDVI &gt; 0.3\n\n# Apply mask\nmasked_image = image.updateMask(mask)\n</code></pre>"},{"location":"usage/#visualization","title":"\ud83d\uddfa\ufe0f Visualization","text":"<p>OpenGeo integrates with <code>leafmap</code> for interactive mapping.</p> <pre><code># Create a map\nm = og.Map(center=[12.97, 77.59], zoom=12)\n\n# Add an RGB layer\nm.addLayer(\n    image, \n    {\"bands\": [\"red\", \"green\", \"blue\"], \"min\": 0, \"max\": 3000}, \n    \"RGB Composite\"\n)\n\n# Add NDVI layer with custom colormap\nm.addLayer(\n    ndvi,\n    {\"min\": -1, \"max\": 1, \"palette\": [\"red\", \"yellow\", \"green\"]},\n    \"NDVI\"\n)\n\n# Center on geometry\nm.centerObject(roi, zoom=12)\n\n# Display map (in Jupyter)\nm\n</code></pre>"},{"location":"usage/#reducers","title":"\ud83d\udcca Reducers","text":"<p>Compute statistics over regions using reducers.</p> <pre><code># Reduce over a region\nstats = ndvi.reduceRegion(\n    reducer=\"mean\",\n    geometry=roi,\n    scale=10  # meters per pixel\n)\nprint(f\"Mean NDVI: {stats}\")\n\n# Multiple reducers\nstats = ndvi.reduceRegion(\n    reducer=[\"mean\", \"median\", \"stdDev\", \"min\", \"max\"],\n    geometry=roi,\n    scale=10\n)\n</code></pre>"},{"location":"usage/#common-workflows","title":"\ud83d\udd04 Common Workflows","text":""},{"location":"usage/#workflow-1-time-series-analysis","title":"Workflow 1: Time Series Analysis","text":"<pre><code># Load collection\ncol = (og.ImageCollection(\"sentinel-2-l2a\")\n       .filterDate(\"2023-01-01\", \"2023-12-31\")\n       .filterBounds(roi)\n       .select([\"red\", \"nir\"]))\n\n# Calculate NDVI for each image\ndef calculate_ndvi(image):\n    ndvi = (image.select(\"nir\") - image.select(\"red\")) / \\\n           (image.select(\"nir\") + image.select(\"red\"))\n    return ndvi.rename(\"ndvi\")\n\nndvi_collection = col.map(calculate_ndvi)\n\n# Extract time series\ntime_series = ndvi_collection.getTimeSeries(geometry=roi, reducer=\"mean\")\n</code></pre>"},{"location":"usage/#workflow-2-multi-sensor-fusion","title":"Workflow 2: Multi-Sensor Fusion","text":"<pre><code># Load Sentinel-2\ns2 = (og.ImageCollection(\"sentinel-2-l2a\")\n      .filterDate(\"2023-06-01\", \"2023-06-30\")\n      .filterBounds(roi)\n      .median())\n\n# Load Landsat 8\nl8 = (og.ImageCollection(\"landsat-c2-l2\")\n      .filterDate(\"2023-06-01\", \"2023-06-30\")\n      .filterBounds(roi)\n      .median())\n\n# Combine datasets\ncombined = s2.addBands(l8)\n</code></pre>"},{"location":"usage/#best-practices","title":"\ud83d\udca1 Best Practices","text":"<p>Performance Tips</p> <ol> <li>Filter early: Apply spatial and temporal filters before processing</li> <li>Select only needed bands: Reduce data transfer and memory usage</li> <li>Use lazy evaluation: Dask only computes when you call <code>.compute()</code></li> <li>Chunk appropriately: Balance chunk size for your workflow</li> </ol> <pre><code># Good: Filter then select\ncol = (og.ImageCollection(\"sentinel-2-l2a\")\n       .filterDate(\"2023-01-01\", \"2023-01-31\")\n       .filterBounds(roi)\n       .select([\"red\", \"nir\"]))\n\n# Bad: Load everything first\ncol = og.ImageCollection(\"sentinel-2-l2a\").select([\"red\", \"nir\"])\n</code></pre> <p>GEE vs OpenGeo</p> Operation Google Earth Engine OpenGeo Initialize <code>ee.Initialize()</code> <code>og.Initialize()</code> Image Collection <code>ee.ImageCollection()</code> <code>og.ImageCollection()</code> Filter Date <code>.filterDate()</code> <code>.filterDate()</code> Filter Bounds <code>.filterBounds()</code> <code>.filterBounds()</code> Reduce <code>.reduce()</code> <code>.mean()</code>, <code>.median()</code>, etc. Map Function <code>.map()</code> <code>.map()</code>"},{"location":"api/","title":"API Reference","text":"<p>The OpenGeo API is structured to mirror the Earth Engine Python API, making it familiar for GEE users transitioning to open-source tools.</p>"},{"location":"api/#core-modules","title":"\ud83e\udde9 Core Modules","text":"<p>OpenGeo provides the following core classes that correspond to Earth Engine's API:</p> OpenGeo Class Earth Engine Equivalent Description <code>og.Image</code> <code>ee.Image</code> Operations on single multi-band raster images <code>og.ImageCollection</code> <code>ee.ImageCollection</code> Operations on groups of raster images <code>og.FeatureCollection</code> <code>ee.FeatureCollection</code> Operations on vector datasets <code>og.Geometry</code> <code>ee.Geometry</code> Defining spatial regions and geometries <code>og.Map</code> <code>geemap.Map</code> Interactive visualization and mapping"},{"location":"api/#quick-navigation","title":"\ud83d\ude80 Quick Navigation","text":"<ul> <li>Image - Work with single raster images, perform band math, and apply masks</li> <li>ImageCollection - Filter, map, and reduce collections of satellite imagery</li> <li>FeatureCollection - Handle vector data with GeoPandas integration</li> <li>Geometry - Create points, polygons, and other geometric shapes</li> <li>Map - Visualize your data interactively with Leafmap</li> </ul> <p>Implementation Details</p> <p>OpenGeo uses the following underlying technologies:</p> <ul> <li>Xarray for n-dimensional array operations</li> <li>Dask for lazy evaluation and parallel computing</li> <li>STAC (SpatioTemporal Asset Catalog) for data discovery</li> <li>GeoPandas for vector data handling</li> <li>Leafmap for interactive visualization</li> </ul>"},{"location":"api/feature_collection/","title":"FeatureCollection","text":""},{"location":"api/feature_collection/#opengeo.feature_collection.FeatureCollection","title":"<code>FeatureCollection</code>","text":"<p>Wrapper for geopandas.GeoDataFrame to mimic ee.FeatureCollection.</p> Source code in <code>opengeo/feature_collection.py</code> <pre><code>class FeatureCollection:\n    \"\"\"Wrapper for geopandas.GeoDataFrame to mimic ee.FeatureCollection.\"\"\"\n\n    def __init__(self, arg):\n        if isinstance(arg, str):\n            # assume path\n            self._gdf = gpd.read_file(arg)\n        elif isinstance(arg, gpd.GeoDataFrame):\n            self._gdf = arg\n        elif isinstance(arg, list):\n             if len(arg) == 0:\n                 self._gdf = gpd.GeoDataFrame(columns=['geometry'], geometry='geometry')\n             elif isinstance(arg[0], Feature):\n                 # List of Features\n                 geoms = [f.geometry().shapely if f.geometry() else None for f in arg]\n                 props = [f.toDictionary() for f in arg]\n                 self._gdf = gpd.GeoDataFrame(props, geometry=geoms)\n             else:\n                 # List of dict/geojson?\n                 # Try to parse\n                 pass\n        elif isinstance(arg, Feature):\n             self._gdf = gpd.GeoDataFrame([arg.toDictionary()], geometry=[arg.geometry().shapely])\n        else:\n            # Maybe it's empty or None?\n            if arg is None:\n                 self._gdf = gpd.GeoDataFrame(columns=['geometry'], geometry='geometry')\n            else:\n                 raise ValueError(f\"Cannot interpret FeatureCollection source: {arg}\")\n\n    def filterBounds(self, geometry):\n        if hasattr(geometry, 'shapely'):\n             geometry = geometry.shapely\n        filtered = self._gdf[self._gdf.intersects(geometry)]\n        return FeatureCollection(filtered)\n\n    def filter(self, expr_or_filter):\n        if isinstance(expr_or_filter, str):\n            filtered = self._gdf.query(expr_or_filter)\n            return FeatureCollection(filtered)\n        elif callable(expr_or_filter):\n            mask = self._gdf.apply(expr_or_filter, axis=1)\n            return FeatureCollection(self._gdf[mask])\n        else:\n             raise NotImplementedError(\"Only string queries (pandas) or callables supported for filter()\")\n\n    def select(self, properties):\n        if isinstance(properties, str): properties = [properties]\n        cols = properties + ['geometry']\n        cols = [c for c in cols if c in self._gdf.columns]\n        return FeatureCollection(self._gdf[cols])\n\n    def map(self, func):\n        new_features = []\n        for i, row in self._gdf.iterrows():\n            geom = Geometry(row.geometry)\n            props = row.drop('geometry').to_dict()\n            feat = Feature(geom, props, id=i)\n            res = func(feat)\n            if isinstance(res, Feature):\n                 new_features.append(res)\n\n        return FeatureCollection(new_features)\n\n    def size(self):\n        return len(self._gdf)\n\n    def first(self):\n        if len(self._gdf) == 0: return None\n        row = self._gdf.iloc[0]\n        return Feature(Geometry(row.geometry), row.drop('geometry').to_dict())\n\n    def getInfo(self):\n        return json.loads(self._gdf.to_json())\n\n    def aggregate_array(self, property):\n        if property in self._gdf.columns:\n            return self._gdf[property].tolist()\n        return []\n\n    def __repr__(self):\n        return f\"og.FeatureCollection({len(self._gdf)} elements)\"\n</code></pre>"},{"location":"api/geometry/","title":"Geometry","text":""},{"location":"api/geometry/#opengeo.geometry.Geometry","title":"<code>Geometry</code>","text":"<p>Wrapper for shapely geometries to mimic ee.Geometry.</p> Source code in <code>opengeo/geometry.py</code> <pre><code>class Geometry:\n    \"\"\"Wrapper for shapely geometries to mimic ee.Geometry.\"\"\"\n\n    def __init__(self, geo_obj, crs=\"EPSG:4326\"):\n        self._geo = geo_obj\n        self.crs = crs\n\n    @property\n    def shapely(self):\n        return self._geo\n\n    @classmethod\n    def Point(cls, x, y):\n        return cls(SPoint(x, y))\n\n    @classmethod\n    def Polygon(cls, coords):\n        # Flatten if necessary or handle ee style nested lists\n        if len(coords) == 1 and isinstance(coords[0], list) and isinstance(coords[0][0], list):\n             # ee style: [[[x,y], [x,y]]] \n             # shapely: [[x,y], [x,y]] (exterior ring)\n             return cls(SPolygon(coords[0]))\n        return cls(SPolygon(coords))\n\n    @classmethod\n    def Rectangle(cls, xMin, yMin, xMax, yMax):\n        return cls(box(xMin, yMin, xMax, yMax))\n\n    @classmethod\n    def LineString(cls, coords):\n        return cls(SLineString(coords))\n\n    def buffer(self, distance):\n        # Distance unit depends on CRS, for simplicity assuming degrees if 4326 \n        # but GEE uses meters. This is a complex point.\n        # For now, just wrap shapely buffer\n        return Geometry(self._geo.buffer(distance), self.crs)\n\n    def bounds(self):\n        return Geometry(box(*self._geo.bounds), self.crs)\n\n    def intersection(self, other):\n        if isinstance(other, Geometry):\n             other = other.shapely\n        return Geometry(self._geo.intersection(other), self.crs)\n\n    def union(self, other):\n        if isinstance(other, Geometry):\n             other = other.shapely\n        return Geometry(self._geo.union(other), self.crs)\n\n    def getInfo(self):\n        # Return GeoJSON dict\n        return json.loads(gpd.GeoSeries([self._geo]).to_json())['features'][0]['geometry']\n\n    def __repr__(self):\n        return f\"og.Geometry({self._geo.wkt})\"\n</code></pre>"},{"location":"api/image/","title":"Image","text":""},{"location":"api/image/#opengeo.image.Image","title":"<code>Image</code>","text":"<p>Wrapper for xarray.DataArray to mimic ee.Image.</p> Source code in <code>opengeo/image.py</code> <pre><code>class Image:\n    \"\"\"Wrapper for xarray.DataArray to mimic ee.Image.\"\"\"\n\n    def __init__(self, data):\n        if isinstance(data, xr.DataArray):\n            self._da = data\n        elif isinstance(data, (int, float)):\n             # Constant image\n             self._da = xr.DataArray(data)\n             # Add dummy coords?\n        elif isinstance(data, str) and (data.startswith(\"http\") or data.endswith(\".tif\")):\n             # Load from URL/Path?\n             # For simplicity, use rioxarray open_rasterio\n             self._da = rioxarray.open_rasterio(data, chunks=\"auto\") \n        else:\n             print(f\"Warning: Image constructor received unknown type: {type(data)}\")\n             self._da = xr.DataArray(data)\n\n    @property  \n    def _data(self):\n        return self._da\n\n    def select(self, bands):\n        if isinstance(bands, str): bands = [bands]\n        # Assuming band dimension exists\n        if 'band' in self._da.dims:\n            return Image(self._da.sel(band=bands))\n        if 'bands' in self._da.dims:\n             return Image(self._da.sel(bands=bands))\n\n        # If no band dim but variables in Dataset? We handle DataArray primarily.\n        return self\n\n    def addBands(self, other):\n        # Merge bands. complicated if coordinates differ.\n        # Xarray align\n        if isinstance(other, Image):\n            other = other._data\n        # If both have band dim, concatenate?\n        # If different bands, merge?\n        # For simplicity, if same coords, just add as new band?\n        # TODO: Implement full merge logic\n        return self \n\n    def clip(self, geometry):\n        if isinstance(geometry, Geometry):\n             geometry = geometry.shapely\n        # User rioxarray clip\n        # Ensure CRS is set\n        if self._da.rio.crs is None:\n             # If constant image, clip doesn't make sense unless we conform to geometry grid\n             # Just return self? Or mask?\n             print(\"Warning: Image has no CRS, skipping clip.\")\n             return self\n\n        try:\n             clipped = self._da.rio.clip([geometry], all_touched=True, drop=True)\n             return Image(clipped)\n        except Exception as e:\n             print(f\"Clip failed: {e}\")\n             return self\n\n    def mask(self):\n        # In GEE returns the mask\n        return Image(self._da.notnull())\n\n    def updateMask(self, mask):\n        if isinstance(mask, Image): mask = mask._data\n        return Image(self._da.where(mask))\n\n    def add(self, other):\n        return self + other\n    def subtract(self, other):\n        return self - other\n    def multiply(self, other):\n        return self * other\n    def divide(self, other):\n        return self / other\n\n    def _prepare_for_math(self, other):\n        val = other._data if isinstance(other, Image) else other\n        self_da = self._da\n\n        if isinstance(val, xr.DataArray):\n            # If both have single band but different names, squeeze to allow math\n            if 'band' in self_da.dims and self_da.sizes['band'] == 1:\n                if 'band' in val.dims and val.sizes['band'] == 1:\n                    return self_da.squeeze('band'), val.squeeze('band')\n            elif 'bands' in self_da.dims and self_da.sizes['bands'] == 1:\n                if 'bands' in val.dims and val.sizes['bands'] == 1:\n                    return self_da.squeeze('bands'), val.squeeze('bands')\n        return self_da, val\n\n    def __add__(self, other):\n        s, o = self._prepare_for_math(other)\n        return Image(s + o)\n    def __sub__(self, other):\n        s, o = self._prepare_for_math(other)\n        return Image(s - o)\n    def __mul__(self, other):\n        s, o = self._prepare_for_math(other)\n        return Image(s * o)\n    def __truediv__(self, other):\n        s, o = self._prepare_for_math(other)\n        return Image(s / o)\n\n    def rename(self, names):\n        # Rename bands\n        if isinstance(names, str): names = [names]\n        da = self._da.copy()\n        if 'band' in da.dims:\n             da['band'] = names\n        elif 'bands' in da.dims:\n             da['bands'] = names\n        return Image(da)\n\n    def reduceRegion(self, reducer='mean', geometry=None, scale=None, bestEffort=False, maxPixels=1e9, tileScale=1):\n        \"\"\"\n        Execute reduction over region using Dask for efficiency.\n        \"\"\"\n        target = self\n        if geometry:\n            target = target.clip(geometry)\n\n        da = target._da\n\n        # Spatial dimensions are usually 'x' and 'y'\n        spatial_dims = []\n        if 'x' in da.dims: spatial_dims.append('x')\n        if 'y' in da.dims: spatial_dims.append('y')\n\n        if not spatial_dims:\n            # Nothing to reduce spatially?\n            return {\"constant\": float(da.compute()) if hasattr(da, 'compute') else float(da)}\n\n        # Define reduction mapping\n        reducers = {\n            'mean': xr.DataArray.mean,\n            'max': xr.DataArray.max,\n            'min': xr.DataArray.min,\n            'sum': xr.DataArray.sum,\n            'count': xr.DataArray.count,\n            'median': xr.DataArray.median\n        }\n\n        if reducer not in reducers:\n            raise ValueError(f\"Unsupported reducer: {reducer}\")\n\n        # Apply lazy reduction\n        reduced = reducers[reducer](da, dim=spatial_dims, keep_attrs=True)\n\n        # Trigger single computation for all bands\n        results = reduced.compute()\n\n        dict_res = {}\n\n        # Handle band dimension if it exists\n        band_dim = None\n        if 'band' in results.dims: band_dim = 'band'\n        elif 'bands' in results.dims: band_dim = 'bands'\n\n        if band_dim:\n            for b in results[band_dim].values:\n                val = results.sel({band_dim: b}).item()\n                dict_res[str(b)] = val\n        else:\n            dict_res['constant'] = results.item()\n\n        return dict_res\n\n    def normalizedDifference(self, bands):\n        if len(bands) != 2:\n            raise ValueError(\"normalizedDifference requires exactly 2 bands.\")\n        b1 = self.select(bands[0])\n        b2 = self.select(bands[1])\n        # Force float to avoid integer division issues\n        return (b1 - b2) / (b1 + b2)\n\n    def to_file(self, path, vmin=None, vmax=None, palette=None, **kwargs):\n        \"\"\"\n        Saves the image to a file. \n        If path ends in .tif, saves as GeoTIFF.\n        If path ends in .jpg or .png, saves as a rendered image.\n        \"\"\"\n        da = self._da\n        if 'band' in da.dims:\n            if da.sizes['band'] == 1:\n                da = da.squeeze('band')\n            elif da.sizes['band'] == 3:\n                # RGB\n                pass\n        elif 'bands' in da.dims:\n            if da.sizes['bands'] == 1:\n                da = da.squeeze('bands')\n            elif da.sizes['bands'] == 3:\n                # RGB\n                pass\n\n        if path.lower().endswith(('.tif', '.tiff')):\n            da.rio.to_raster(path, **kwargs)\n        else:\n            import matplotlib.pyplot as plt\n            # Normalize for visualization if not RGB\n            is_rgb = (len(da.shape) == 3 and (da.shape[0] == 3 or da.shape[-1] == 3))\n\n            plt.figure(figsize=(10, 10))\n            if is_rgb:\n                # Handle (C, H, W) to (H, W, C) for matplotlib if needed\n                if da.shape[0] == 3:\n                    da = da.transpose('y', 'x', 'band') if 'band' in da.dims else da.transpose('y', 'x', 'bands')\n                da.plot.imshow(vmin=vmin, vmax=vmax)\n            else:\n                da.plot.imshow(cmap=palette or 'viridis', vmin=vmin, vmax=vmax)\n\n            plt.axis('off')\n            plt.savefig(path, bbox_inches='tight', pad_inches=0)\n            plt.close()\n            print(f\"Image saved to {path}\")\n\n    def getInfo(self):\n        # Metadata\n        bands = []\n        if 'band' in self._da.dims: bands = self._da.band.values.tolist()\n        elif 'bands' in self._da.dims: bands = self._da.bands.values.tolist()\n\n        return {\n            'type': 'Image',\n            'bands': bands,\n            'dtype': str(self._da.dtype),\n            'shape': self._da.shape,\n            'crs': str(self._da.rio.crs) if hasattr(self._da, 'rio') else None\n        }\n\n    def __repr__(self):\n        import json\n        return f\"og.Image({json.dumps(self.getInfo(), indent=2)})\"\n</code></pre>"},{"location":"api/image/#opengeo.image.Image.reduceRegion","title":"<code>reduceRegion(reducer='mean', geometry=None, scale=None, bestEffort=False, maxPixels=1000000000.0, tileScale=1)</code>","text":"<p>Execute reduction over region using Dask for efficiency.</p> Source code in <code>opengeo/image.py</code> <pre><code>def reduceRegion(self, reducer='mean', geometry=None, scale=None, bestEffort=False, maxPixels=1e9, tileScale=1):\n    \"\"\"\n    Execute reduction over region using Dask for efficiency.\n    \"\"\"\n    target = self\n    if geometry:\n        target = target.clip(geometry)\n\n    da = target._da\n\n    # Spatial dimensions are usually 'x' and 'y'\n    spatial_dims = []\n    if 'x' in da.dims: spatial_dims.append('x')\n    if 'y' in da.dims: spatial_dims.append('y')\n\n    if not spatial_dims:\n        # Nothing to reduce spatially?\n        return {\"constant\": float(da.compute()) if hasattr(da, 'compute') else float(da)}\n\n    # Define reduction mapping\n    reducers = {\n        'mean': xr.DataArray.mean,\n        'max': xr.DataArray.max,\n        'min': xr.DataArray.min,\n        'sum': xr.DataArray.sum,\n        'count': xr.DataArray.count,\n        'median': xr.DataArray.median\n    }\n\n    if reducer not in reducers:\n        raise ValueError(f\"Unsupported reducer: {reducer}\")\n\n    # Apply lazy reduction\n    reduced = reducers[reducer](da, dim=spatial_dims, keep_attrs=True)\n\n    # Trigger single computation for all bands\n    results = reduced.compute()\n\n    dict_res = {}\n\n    # Handle band dimension if it exists\n    band_dim = None\n    if 'band' in results.dims: band_dim = 'band'\n    elif 'bands' in results.dims: band_dim = 'bands'\n\n    if band_dim:\n        for b in results[band_dim].values:\n            val = results.sel({band_dim: b}).item()\n            dict_res[str(b)] = val\n    else:\n        dict_res['constant'] = results.item()\n\n    return dict_res\n</code></pre>"},{"location":"api/image/#opengeo.image.Image.to_file","title":"<code>to_file(path, vmin=None, vmax=None, palette=None, **kwargs)</code>","text":"<p>Saves the image to a file.  If path ends in .tif, saves as GeoTIFF. If path ends in .jpg or .png, saves as a rendered image.</p> Source code in <code>opengeo/image.py</code> <pre><code>def to_file(self, path, vmin=None, vmax=None, palette=None, **kwargs):\n    \"\"\"\n    Saves the image to a file. \n    If path ends in .tif, saves as GeoTIFF.\n    If path ends in .jpg or .png, saves as a rendered image.\n    \"\"\"\n    da = self._da\n    if 'band' in da.dims:\n        if da.sizes['band'] == 1:\n            da = da.squeeze('band')\n        elif da.sizes['band'] == 3:\n            # RGB\n            pass\n    elif 'bands' in da.dims:\n        if da.sizes['bands'] == 1:\n            da = da.squeeze('bands')\n        elif da.sizes['bands'] == 3:\n            # RGB\n            pass\n\n    if path.lower().endswith(('.tif', '.tiff')):\n        da.rio.to_raster(path, **kwargs)\n    else:\n        import matplotlib.pyplot as plt\n        # Normalize for visualization if not RGB\n        is_rgb = (len(da.shape) == 3 and (da.shape[0] == 3 or da.shape[-1] == 3))\n\n        plt.figure(figsize=(10, 10))\n        if is_rgb:\n            # Handle (C, H, W) to (H, W, C) for matplotlib if needed\n            if da.shape[0] == 3:\n                da = da.transpose('y', 'x', 'band') if 'band' in da.dims else da.transpose('y', 'x', 'bands')\n            da.plot.imshow(vmin=vmin, vmax=vmax)\n        else:\n            da.plot.imshow(cmap=palette or 'viridis', vmin=vmin, vmax=vmax)\n\n        plt.axis('off')\n        plt.savefig(path, bbox_inches='tight', pad_inches=0)\n        plt.close()\n        print(f\"Image saved to {path}\")\n</code></pre>"},{"location":"api/image_collection/","title":"ImageCollection","text":""},{"location":"api/image_collection/#opengeo.image_collection.ImageCollection","title":"<code>ImageCollection</code>","text":"<p>Wrapper for STAC search + stackstac to mimic ee.ImageCollection.</p> Source code in <code>opengeo/image_collection.py</code> <pre><code>class ImageCollection:\n    \"\"\"Wrapper for STAC search + stackstac to mimic ee.ImageCollection.\"\"\"\n\n    def __init__(self, collection_id, api_url=None, filters=None, bands=None):\n        self._id = collection_id\n        if isinstance(collection_id, ImageCollection):\n             # Copy constructor logic if passed an instance\n             self._id = collection_id._id\n             self._api = collection_id._api\n             self._filters = copy.deepcopy(collection_id._filters)\n             self._bands = copy.deepcopy(collection_id._bands)\n             return\n\n        self._api = api_url or get_stac_api()\n        self._filters = filters or {\n            \"collections\": [self._id] if self._id else [],\n            \"datetime\": None,\n            \"intersects\": None,\n            \"bbox\": None\n        }\n        self._bands = bands # Assets\n\n    def _clone(self):\n        # Helper to create a copy\n        return ImageCollection(\n            self._id, \n            api_url=self._api, \n            filters=copy.deepcopy(self._filters),\n            bands=copy.deepcopy(self._bands)\n        )\n\n    def filterDate(self, start, end):\n        new_col = self._clone()\n        # start, end are strings 'YYYY-MM-DD'\n        new_col._filters[\"datetime\"] = f\"{start}/{end}\"\n        return new_col\n\n    def filterBounds(self, geometry):\n        new_col = self._clone()\n        if isinstance(geometry, Geometry):\n             new_col._filters[\"intersects\"] = geometry.shapely\n        else:\n             # Assume shapely or GeoJSON dict\n             new_col._filters[\"intersects\"] = geometry\n        return new_col\n\n    def filter(self, **kwargs):\n        \"\"\"Add arbitrary STAC filters.\"\"\"\n        new_col = self._clone()\n        new_col._filters.update(kwargs)\n        return new_col\n\n    def select(self, bands):\n        new_col = self._clone()\n        if isinstance(bands, str): bands = [bands]\n        new_col._bands = bands\n        return new_col\n\n    def _search(self):\n        # Check for MS Planetary Computer\n        modifier = None\n        if \"planetarycomputer\" in self._api:\n            try:\n                import planetary_computer\n                modifier = planetary_computer.sign_inplace\n            except ImportError:\n                 print(\"Warning: accessing Microsoft Planetary Computer but 'planetary-computer' package is not installed.\")\n\n        client = Client.open(self._api, modifier=modifier)\n        # remove None values\n        params = {k: v for k, v in self._filters.items() if v is not None}\n\n        search = client.search(**params)\n        return search.item_collection()\n\n    def _to_xarray(self, **kwargs):\n        items = self._search()\n        if len(items) == 0:\n            raise ValueError(f\"No images found in collection '{self._id}' with current filters.\")\n\n        # Determine bounds from filters if possible\n        bounds_latlon = None\n        if self._filters[\"intersects\"]:\n             try:\n                 bounds_latlon = self._filters[\"intersects\"].bounds\n             except: pass\n\n        # Load stack. \n        da = stackstac.stack(\n             items, \n             assets=self._bands, \n             bounds_latlon=bounds_latlon,\n             **kwargs\n        )\n        return da\n\n    def mean(self, **kwargs):\n        da = self._to_xarray(**kwargs)\n        # Reduce time dimension\n        return Image(da.mean(dim=\"time\", keep_attrs=True))\n\n    def median(self, **kwargs):\n        da = self._to_xarray(**kwargs)\n        return Image(da.median(dim=\"time\", keep_attrs=True))\n\n    def min(self, **kwargs):\n        da = self._to_xarray(**kwargs)\n        return Image(da.min(dim=\"time\", keep_attrs=True))\n\n    def max(self, **kwargs):\n        da = self._to_xarray(**kwargs)\n        return Image(da.max(dim=\"time\", keep_attrs=True))\n\n    def mosaic(self, **kwargs):\n        # Mosaic by taking max (common simple mosaic) or last.\n        # stackstac.mosaic is more sophisticated if available.\n        # Fallback to mean/median/max\n        return self.max(**kwargs) \n\n    def first(self, **kwargs):\n        # Return first image\n        try:\n             client = Client.open(self._api)\n             params = {k: v for k, v in self._filters.items() if v is not None}\n             params['max_items'] = 1\n             search = client.search(**params)\n             items = list(search.items())\n             if not items: return None\n             da = stackstac.stack(items[0], assets=self._bands, **kwargs)\n             return Image(da.squeeze(\"time\"))\n        except Exception as e:\n             print(f\"Error fetching first image: {e}\")\n             return None\n\n    def size(self):\n        return len(self._search())\n\n    def getInfo(self):\n        return [i.to_dict() for i in self._search()]\n\n    def __repr__(self):\n        return f\"og.ImageCollection({self._id}, filters={self._filters})\"\n</code></pre>"},{"location":"api/image_collection/#opengeo.image_collection.ImageCollection.filter","title":"<code>filter(**kwargs)</code>","text":"<p>Add arbitrary STAC filters.</p> Source code in <code>opengeo/image_collection.py</code> <pre><code>def filter(self, **kwargs):\n    \"\"\"Add arbitrary STAC filters.\"\"\"\n    new_col = self._clone()\n    new_col._filters.update(kwargs)\n    return new_col\n</code></pre>"},{"location":"api/map/","title":"Map","text":""},{"location":"api/map/#opengeo.map.Map","title":"<code>Map</code>","text":"<p>               Bases: <code>Map</code></p> <p>Class to mimic GEE Map for visualization. Uses leafmap as the engine, supporting backends:  'ipyleaflet' (default), 'folium', 'heremap', 'keplergl', etc.</p> Source code in <code>opengeo/map.py</code> <pre><code>class Map(leafmap.Map):\n    \"\"\"\n    Class to mimic GEE Map for visualization.\n    Uses leafmap as the engine, supporting backends: \n    'ipyleaflet' (default), 'folium', 'heremap', 'keplergl', etc.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        # Allow backend selection: og.Map(backend='folium')\n        if 'center' not in kwargs:\n            kwargs['center'] = [20, 0]\n        if 'zoom' not in kwargs:\n            kwargs['zoom'] = 2\n        super().__init__(**kwargs)\n\n    def addLayer(self, ee_object, vis_params=None, name=None, shown=True, opacity=1):\n        \"\"\"\n        Adds a layer to the map in GEE style.\n\n        Args:\n            ee_object: The object to add (Image, ImageCollection, etc.)\n            vis_params: Dictionary of visualization parameters (min, max, palette, bands)\n            name: Layer name\n            shown: Whether the layer is visible\n            opacity: Layer opacity\n        \"\"\"\n        if vis_params is None:\n            vis_params = {}\n\n        if name is None:\n            name = \"Layer \" + str(len(self.layers))\n\n        if isinstance(ee_object, Image):\n            da = ee_object._data\n\n            # Handle band selection in vis_params\n            sel_bands = vis_params.get('bands', None)\n            if sel_bands:\n                if isinstance(sel_bands, str): sel_bands = [sel_bands]\n                if 'band' in da.dims:\n                    da = da.sel(band=sel_bands)\n                elif 'bands' in da.dims:\n                    da = da.sel(bands=sel_bands)\n\n            # Handle palette/cmap\n            cmap = vis_params.get('palette', 'viridis')\n            if isinstance(cmap, str) and ',' in cmap:\n                cmap = [c.strip() for c in cmap.split(',')]\n\n            vmin = vis_params.get('min', None)\n            vmax = vis_params.get('max', None)\n\n            # Prepare data for leafmap.add_raster\n            plot_da = da\n            # Squeeze single bands if not RGB\n            is_rgb = False\n            if 'band' in plot_da.dims and plot_da.sizes['band'] == 3: is_rgb = True\n            elif 'bands' in plot_da.dims and plot_da.sizes['bands'] == 3: is_rgb = True\n\n            if not is_rgb:\n                if 'band' in plot_da.dims and plot_da.sizes['band'] == 1:\n                    plot_da = plot_da.squeeze('band')\n                elif 'bands' in plot_da.dims and plot_da.sizes['bands'] == 1:\n                    plot_da = plot_da.squeeze('bands')\n\n            self.add_raster(\n                plot_da, \n                layer_name=name, \n                cmap=cmap, \n                vmin=vmin, \n                vmax=vmax, \n                opacity=opacity,\n                visible=shown\n            )\n\n        elif isinstance(ee_object, ImageCollection):\n            # For ImageCollection, visualize the mosaic\n            return self.addLayer(ee_object.mosaic(), vis_params, name, shown, opacity)\n\n        elif isinstance(ee_object, (Feature, FeatureCollection)):\n            # TODO: add_gdf support\n            pass\n\n        return self\n\n    def centerObject(self, obj, zoom=None):\n        \"\"\"Centers the map on an object.\"\"\"\n        from .geometry import Geometry\n\n        b = None\n        if isinstance(obj, Geometry):\n            b = obj.shapely.bounds # (minx, miny, maxx, maxy)\n        elif hasattr(obj, 'bounds'):\n            b = obj.bounds\n            if callable(b): b = b()\n\n        if b and isinstance(b, (tuple, list)) and len(b) == 4:\n            # leafmap zoom_to_bounds expects [minx, miny, maxx, maxy] per help\n            # but ipyleaflet uses lat/lon [[miny, minx], [maxy, maxx]]\n            # Let's try the leafmap standard list format\n            try:\n                self.zoom_to_bounds(bounds=[b[0], b[1], b[2], b[3]])\n            except:\n                self.fit_bounds([[b[1], b[0]], [b[3], b[2]]])\n\n        if zoom is not None:\n             self.zoom = zoom\n\n    def add_layer(self, *args, **kwargs):\n        # Maintain leafmap's native add_layer support\n        return super().add_layer(*args, **kwargs)\n</code></pre>"},{"location":"api/map/#opengeo.map.Map.addLayer","title":"<code>addLayer(ee_object, vis_params=None, name=None, shown=True, opacity=1)</code>","text":"<p>Adds a layer to the map in GEE style.</p> <p>Parameters:</p> Name Type Description Default <code>ee_object</code> <p>The object to add (Image, ImageCollection, etc.)</p> required <code>vis_params</code> <p>Dictionary of visualization parameters (min, max, palette, bands)</p> <code>None</code> <code>name</code> <p>Layer name</p> <code>None</code> <code>shown</code> <p>Whether the layer is visible</p> <code>True</code> <code>opacity</code> <p>Layer opacity</p> <code>1</code> Source code in <code>opengeo/map.py</code> <pre><code>def addLayer(self, ee_object, vis_params=None, name=None, shown=True, opacity=1):\n    \"\"\"\n    Adds a layer to the map in GEE style.\n\n    Args:\n        ee_object: The object to add (Image, ImageCollection, etc.)\n        vis_params: Dictionary of visualization parameters (min, max, palette, bands)\n        name: Layer name\n        shown: Whether the layer is visible\n        opacity: Layer opacity\n    \"\"\"\n    if vis_params is None:\n        vis_params = {}\n\n    if name is None:\n        name = \"Layer \" + str(len(self.layers))\n\n    if isinstance(ee_object, Image):\n        da = ee_object._data\n\n        # Handle band selection in vis_params\n        sel_bands = vis_params.get('bands', None)\n        if sel_bands:\n            if isinstance(sel_bands, str): sel_bands = [sel_bands]\n            if 'band' in da.dims:\n                da = da.sel(band=sel_bands)\n            elif 'bands' in da.dims:\n                da = da.sel(bands=sel_bands)\n\n        # Handle palette/cmap\n        cmap = vis_params.get('palette', 'viridis')\n        if isinstance(cmap, str) and ',' in cmap:\n            cmap = [c.strip() for c in cmap.split(',')]\n\n        vmin = vis_params.get('min', None)\n        vmax = vis_params.get('max', None)\n\n        # Prepare data for leafmap.add_raster\n        plot_da = da\n        # Squeeze single bands if not RGB\n        is_rgb = False\n        if 'band' in plot_da.dims and plot_da.sizes['band'] == 3: is_rgb = True\n        elif 'bands' in plot_da.dims and plot_da.sizes['bands'] == 3: is_rgb = True\n\n        if not is_rgb:\n            if 'band' in plot_da.dims and plot_da.sizes['band'] == 1:\n                plot_da = plot_da.squeeze('band')\n            elif 'bands' in plot_da.dims and plot_da.sizes['bands'] == 1:\n                plot_da = plot_da.squeeze('bands')\n\n        self.add_raster(\n            plot_da, \n            layer_name=name, \n            cmap=cmap, \n            vmin=vmin, \n            vmax=vmax, \n            opacity=opacity,\n            visible=shown\n        )\n\n    elif isinstance(ee_object, ImageCollection):\n        # For ImageCollection, visualize the mosaic\n        return self.addLayer(ee_object.mosaic(), vis_params, name, shown, opacity)\n\n    elif isinstance(ee_object, (Feature, FeatureCollection)):\n        # TODO: add_gdf support\n        pass\n\n    return self\n</code></pre>"},{"location":"api/map/#opengeo.map.Map.centerObject","title":"<code>centerObject(obj, zoom=None)</code>","text":"<p>Centers the map on an object.</p> Source code in <code>opengeo/map.py</code> <pre><code>def centerObject(self, obj, zoom=None):\n    \"\"\"Centers the map on an object.\"\"\"\n    from .geometry import Geometry\n\n    b = None\n    if isinstance(obj, Geometry):\n        b = obj.shapely.bounds # (minx, miny, maxx, maxy)\n    elif hasattr(obj, 'bounds'):\n        b = obj.bounds\n        if callable(b): b = b()\n\n    if b and isinstance(b, (tuple, list)) and len(b) == 4:\n        # leafmap zoom_to_bounds expects [minx, miny, maxx, maxy] per help\n        # but ipyleaflet uses lat/lon [[miny, minx], [maxy, maxx]]\n        # Let's try the leafmap standard list format\n        try:\n            self.zoom_to_bounds(bounds=[b[0], b[1], b[2], b[3]])\n        except:\n            self.fit_bounds([[b[1], b[0]], [b[3], b[2]]])\n\n    if zoom is not None:\n         self.zoom = zoom\n</code></pre>"},{"location":"examples/gee_stac_explorer/","title":"Google Earth Engine STAC Explorer with OpenGeo","text":"In\u00a0[1]: Copied! <pre>import opengeo as og\nfrom pystac_client import Client\n\nog.Initialize(\"GEE\")\napi_url = og.get_stac_api()\nprint(f\"Connected to: {api_url}\")\n</pre> import opengeo as og from pystac_client import Client  og.Initialize(\"GEE\") api_url = og.get_stac_api() print(f\"Connected to: {api_url}\") <pre>C:\\Users\\pulak\\anaconda3\\envs\\maps\\Lib\\site-packages\\pyproj\\network.py:59: UserWarning: pyproj unable to set PROJ database path.\n  _set_context_ca_bundle_path(ca_bundle_path)\n</pre> <pre>OpenGeo initialized with STAC API: https://earthengine-stac.storage.googleapis.com/catalog/catalog.json\nConnected to: https://earthengine-stac.storage.googleapis.com/catalog/catalog.json\n</pre> In\u00a0[2]: Copied! <pre>client = Client.open(api_url)\n# List first 5 collections found in the catalog\ncollections = [c.id for i, c in enumerate(client.get_collections()) if i &lt; 5]\nprint(\"GEE Collections:\", collections)\n</pre> client = Client.open(api_url) # List first 5 collections found in the catalog collections = [c.id for i, c in enumerate(client.get_collections()) if i &lt; 5] print(\"GEE Collections:\", collections) <pre>GEE Collections: []\n</pre> In\u00a0[3]: Copied! <pre>try:\n    s2_metadata = client.get_collection(\"COPERNICUS/S2\")\n    print(f\"Collection Title: {s2_metadata.title}\")\n    print(f\"Description Snippet: {s2_metadata.description[:100]}...\")\nexcept Exception as e:\n    print(\"Could not fetch metadata (static catalog might be deep):\", e)\n</pre> try:     s2_metadata = client.get_collection(\"COPERNICUS/S2\")     print(f\"Collection Title: {s2_metadata.title}\")     print(f\"Description Snippet: {s2_metadata.description[:100]}...\") except Exception as e:     print(\"Could not fetch metadata (static catalog might be deep):\", e) <pre>Could not fetch metadata (static catalog might be deep): 'Collection COPERNICUS/S2 not found on catalog'\n</pre>"},{"location":"examples/gee_stac_explorer/#google-earth-engine-stac-explorer-with-opengeo","title":"Google Earth Engine STAC Explorer with OpenGeo\u00b6","text":"<p>This notebook demonstrates how to explore the Google Earth Engine (GEE) STAC Catalog using the <code>opengeo</code> package.</p>"},{"location":"examples/gee_stac_explorer/#1-initialize-opengeo","title":"1. Initialize OpenGeo\u00b6","text":"<p>The <code>GEE</code> alias points to the static STAC catalog on Google Cloud Storage.</p>"},{"location":"examples/gee_stac_explorer/#2-list-gee-collections","title":"2. List GEE Collections\u00b6","text":"<p>Since this is a large static catalog, we can access it using <code>pystac_client</code> to browse the top-level collections.</p>"},{"location":"examples/gee_stac_explorer/#3-metadata-for-a-collection","title":"3. Metadata for a Collection\u00b6","text":"<p>We can retrieve metadata for a specific dataset like Sentinel-2.</p>"},{"location":"examples/intro/","title":"Examples","text":"<p>This section contains a collection of Jupyter notebooks demonstrating the capabilities of OpenGeo for various remote sensing tasks.</p>"},{"location":"examples/intro/#available-examples","title":"\ud83d\udcd3 Available Examples","text":""},{"location":"examples/intro/#vegetation-analysis","title":"Vegetation Analysis","text":"<p>NDVI Analysis Learn how to calculate the Normalized Difference Vegetation Index using Landsat 8 data.</p>      :material-download: Download         :simple-googlecolab: Open in Colab"},{"location":"examples/intro/#optical-imagery","title":"Optical Imagery","text":"<p>Sentinel-2 Exploration Accessing and visualizing Sentinel-2 imagery from Element84.</p>      :material-download: Download         :simple-googlecolab: Open in Colab    <p>Landsat 8 USGS Working with Landsat 8 collections from the USGS STAC API.</p>      :material-download: Download         :simple-googlecolab: Open in Colab"},{"location":"examples/intro/#earth-observation-products","title":"Earth Observation Products","text":"<p>MODIS NASA Accessing land surface temperature or other MODIS products.</p>      :material-download: Download         :simple-googlecolab: Open in Colab"},{"location":"examples/intro/#radar-imagery","title":"Radar Imagery","text":"<p>SAR Analysis Working with Synthetic Aperture Radar data from Umbra and Capella.</p>      :material-download: Download         :simple-googlecolab: Open in Colab"},{"location":"examples/intro/#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>Running Notebooks</p> <p>Option 1: Download and Run Locally</p> <ol> <li>Click the Download button above</li> <li>Open in your preferred environment:<ul> <li>Jupyter Lab: <code>jupyter lab notebook_name.ipynb</code></li> <li>VS Code: Open with Jupyter extension</li> <li>JupyterHub: Upload to your server</li> </ul> </li> </ol> <p>Option 2: Run in Google Colab (Cloud)</p> <ol> <li>Click Open in Colab button</li> <li>The notebook opens in Google Colab (free cloud environment)</li> <li>No local installation needed!</li> <li>Note: You may need to install OpenGeo in Colab:    <pre><code>!pip install git+https://github.com/pulakeshpradhan/opengeo.git\n</code></pre></li> </ol> <p>Requirements</p> <p>For Local Execution:</p> <p>Make sure you have OpenGeo and its dependencies installed: <pre><code>pip install -e .\n</code></pre></p> <p>For Google Colab:</p> <p>Add this cell at the beginning of the notebook: <pre><code># Install OpenGeo in Colab\n!pip install git+https://github.com/pulakeshpradhan/opengeo.git\n</code></pre></p> <p>Pro Tips</p> <ul> <li>\ud83c\udf10 Colab is great for quick testing without local setup</li> <li>\ud83d\udcbb Local is better for large datasets and production workflows</li> <li>\ud83d\udcca All notebooks include visualization examples</li> <li>\ud83d\udd04 Notebooks are regularly updated with new features</li> </ul>"},{"location":"examples/landsat8_ndvi_analysis/","title":"NDVI Analysis with Landsat 8 using OpenGeo (GEE Style)","text":"In\u00a0[1]: Copied! <pre># Option 1: Install from source (recommended for local development)\n# !pip install -e ../..\n\n# Option 2: Install from wheel (adjust path if needed)\n# !pip install ../../dist/opengeo-0.0.1-py3-none-any.whl\n</pre> # Option 1: Install from source (recommended for local development) # !pip install -e ../..  # Option 2: Install from wheel (adjust path if needed) # !pip install ../../dist/opengeo-0.0.1-py3-none-any.whl In\u00a0[2]: Copied! <pre>import opengeo as og\nimport os\n\n# Enable no-sign-request for public data access\nos.environ['AWS_NO_SIGN_REQUEST'] = 'YES'\n\nog.Initialize(\"MICROSOFT\")\n</pre> import opengeo as og import os  # Enable no-sign-request for public data access os.environ['AWS_NO_SIGN_REQUEST'] = 'YES'  og.Initialize(\"MICROSOFT\") <pre>C:\\Users\\pulak\\anaconda3\\envs\\maps\\Lib\\site-packages\\pyproj\\network.py:59: UserWarning: pyproj unable to set PROJ database path.\n  _set_context_ca_bundle_path(ca_bundle_path)\n</pre> <pre>OpenGeo initialized with STAC API: https://planetarycomputer.microsoft.com/api/stac/v1/\n</pre> In\u00a0[3]: Copied! <pre>roi = og.Geometry.Rectangle(77.55, 12.90, 77.65, 13.00)\nprint(\"ROI:\", roi)\n</pre> roi = og.Geometry.Rectangle(77.55, 12.90, 77.65, 13.00) print(\"ROI:\", roi) <pre>ROI: og.Geometry(POLYGON ((77.65 12.9, 77.65 13, 77.55 13, 77.55 12.9, 77.65 12.9)))\n</pre> In\u00a0[4]: Copied! <pre>l8_col = og.ImageCollection(\"landsat-c2-l2\") \\\n    .filterDate(\"2023-01-01\", \"2023-03-31\") \\\n    .filterBounds(roi) \\\n    .filter(query={\"platform\": {\"eq\": \"landsat-8\"}}) \\\n    .select([\"red\", \"nir08\"])\n\nprint(f\"Images found: {l8_col.size()}\")\n</pre> l8_col = og.ImageCollection(\"landsat-c2-l2\") \\     .filterDate(\"2023-01-01\", \"2023-03-31\") \\     .filterBounds(roi) \\     .filter(query={\"platform\": {\"eq\": \"landsat-8\"}}) \\     .select([\"red\", \"nir08\"])  print(f\"Images found: {l8_col.size()}\") <pre>Images found: 5\n</pre> In\u00a0[5]: Copied! <pre># Median composite (reducing over time)\nimage = l8_col.median(epsg=32643)\n\n# Calculate NDVI\nndvi = image.normalizedDifference([\"nir08\", \"red\"]).rename(\"NDVI\")\n\nprint(\"NDVI Image metadata:\")\nprint(ndvi)\n</pre> # Median composite (reducing over time) image = l8_col.median(epsg=32643)  # Calculate NDVI ndvi = image.normalizedDifference([\"nir08\", \"red\"]).rename(\"NDVI\")  print(\"NDVI Image metadata:\") print(ndvi) <pre>NDVI Image metadata:\nog.Image({\n  \"type\": \"Image\",\n  \"bands\": [],\n  \"dtype\": \"float64\",\n  \"shape\": [\n    367,\n    360\n  ],\n  \"crs\": \"EPSG:32643\"\n})\n</pre> In\u00a0[6]: Copied! <pre>Map = og.Map()\n\nvis_params = {\n    'min': 0,\n    'max': 0.8,\n    'palette': 'red, yellow, green'\n}\n\nMap.addLayer(ndvi, vis_params, \"Landsat 8 NDVI\")\nMap.centerObject(roi, zoom=12)\nMap\n</pre> Map = og.Map()  vis_params = {     'min': 0,     'max': 0.8,     'palette': 'red, yellow, green' }  Map.addLayer(ndvi, vis_params, \"Landsat 8 NDVI\") Map.centerObject(roi, zoom=12) Map Out[6]: In\u00a0[7]: Copied! <pre>stats = ndvi.reduceRegion(\n    reducer='mean', \n    geometry=roi, \n    scale=100\n)\nprint(\"Mean NDVI across ROI:\", stats)\n</pre> stats = ndvi.reduceRegion(     reducer='mean',      geometry=roi,      scale=100 ) print(\"Mean NDVI across ROI:\", stats) <pre>Clip failed: No data found in bounds. Data variable: stackstac-fe16c1c21456ab3bb3fb458678044f1c\n</pre> <pre>Mean NDVI across ROI: {'constant': 0.30835150434594366}\n</pre>"},{"location":"examples/landsat8_ndvi_analysis/#ndvi-analysis-with-landsat-8-using-opengeo-gee-style","title":"NDVI Analysis with Landsat 8 using OpenGeo (GEE Style)\u00b6","text":"<p>This notebook demonstrates how to perform NDVI analysis using the <code>opengeo</code> package. The API is designed to feel like Google Earth Engine (GEE) but runs locally using <code>xarray</code>, <code>stackstac</code>, and <code>leafmap</code>.</p>"},{"location":"examples/landsat8_ndvi_analysis/#0-install-opengeo-if-needed","title":"0. Install OpenGeo (if needed)\u00b6","text":"<p>If you haven't installed OpenGeo yet, you can do so from the root directory or using the wheel file.</p>"},{"location":"examples/landsat8_ndvi_analysis/#1-initialize-opengeo","title":"1. Initialize OpenGeo\u00b6","text":"<p>OpenGeo can be initialized with various STAC API endpoints. Microsoft Planetary Computer is recommended for high-quality Landsat 8 data.</p>"},{"location":"examples/landsat8_ndvi_analysis/#2-define-region-of-interest-roi","title":"2. Define Region of Interest (ROI)\u00b6","text":"<p>Define a rectangular region over Bangalore.</p>"},{"location":"examples/landsat8_ndvi_analysis/#3-load-landsat-8-collection","title":"3. Load Landsat 8 Collection\u00b6","text":"<p>Filter by date and bounds. We'll select the Red and NIR bands for NDVI calculation.</p>"},{"location":"examples/landsat8_ndvi_analysis/#4-compute-median-composite-and-ndvi","title":"4. Compute Median Composite and NDVI\u00b6","text":"<p>Create a median composite to remove clouds and then calculate NDVI: <code>(NIR - Red) / (NIR + Red)</code>.</p>"},{"location":"examples/landsat8_ndvi_analysis/#5-visualize-on-map","title":"5. Visualize on Map\u00b6","text":"<p>Display the NDVI results using an interactive map.</p>"},{"location":"examples/landsat8_ndvi_analysis/#6-zonal-statistics","title":"6. Zonal Statistics\u00b6","text":"<p>Calculate the mean NDVI value for the entire region.</p>"},{"location":"examples/landsat_analysis_usgs/","title":"Landsat C2 Analysis with OpenGeo (USGS LandsatLook)","text":"In\u00a0[\u00a0]: Copied! <pre>import opengeo as og\n\n# Initialize with USGS LandsatLook STAC\nog.Initialize(\"https://landsatlook.usgs.gov/stac-server\")\n</pre> import opengeo as og  # Initialize with USGS LandsatLook STAC og.Initialize(\"https://landsatlook.usgs.gov/stac-server\") In\u00a0[\u00a0]: Copied! <pre>roi = og.Geometry.Rectangle(0, 20, 5, 25)\nprint(\"ROI:\", roi)\n</pre> roi = og.Geometry.Rectangle(0, 20, 5, 25) print(\"ROI:\", roi) In\u00a0[\u00a0]: Copied! <pre>l9_col = og.ImageCollection(\"landsat-c2l2-sr\") \\\n    .filterDate(\"2023-01-01\", \"2023-06-30\") \\\n    .filterBounds(roi) \\\n    .select([\"red\", \"green\", \"blue\", \"nir08\"])\n\nprint(f\"Images found: {l9_col.size()}\")\n</pre> l9_col = og.ImageCollection(\"landsat-c2l2-sr\") \\     .filterDate(\"2023-01-01\", \"2023-06-30\") \\     .filterBounds(roi) \\     .select([\"red\", \"green\", \"blue\", \"nir08\"])  print(f\"Images found: {l9_col.size()}\") In\u00a0[\u00a0]: Copied! <pre># Specify EPSG to ensure consistent CRS mapping\nl9_image = l9_col.median(epsg=3857)\n\nMap = og.Map()\nMap.addLayer(l9_image, {'bands': ['red', 'green', 'blue'], 'min': 0, 'max': 0.2}, \"Landsat 9 RGB\")\nMap.centerObject(roi, zoom=6)\nMap\n</pre> # Specify EPSG to ensure consistent CRS mapping l9_image = l9_col.median(epsg=3857)  Map = og.Map() Map.addLayer(l9_image, {'bands': ['red', 'green', 'blue'], 'min': 0, 'max': 0.2}, \"Landsat 9 RGB\") Map.centerObject(roi, zoom=6) Map"},{"location":"examples/landsat_analysis_usgs/#landsat-c2-analysis-with-opengeo-usgs-landsatlook","title":"Landsat C2 Analysis with OpenGeo (USGS LandsatLook)\u00b6","text":"<p>This notebook demonstrates how to access the USGS LandsatLook STAC API using the <code>opengeo</code> package.</p>"},{"location":"examples/landsat_analysis_usgs/#1-initialize-opengeo","title":"1. Initialize OpenGeo\u00b6","text":""},{"location":"examples/landsat_analysis_usgs/#2-define-roi","title":"2. Define ROI\u00b6","text":"<p>Define a region over the Sahara Desert.</p>"},{"location":"examples/landsat_analysis_usgs/#3-load-landsat-9-collection","title":"3. Load Landsat 9 Collection\u00b6","text":"<p>Landsat 9 collection on USGS is <code>landsat-c2l2-sr</code>.</p>"},{"location":"examples/landsat_analysis_usgs/#4-true-color-visualization","title":"4. True Color Visualization\u00b6","text":"<p>We specify <code>epsg=3857</code> (Web Mercator) for the composite.</p>"},{"location":"examples/modis_analysis_nasa/","title":"MODIS Surface Reflectance with OpenGeo (Planetary Computer)","text":"In\u00a0[\u00a0]: Copied! <pre>import opengeo as og\n\n# Initialize with Microsoft Planetary Computer\nog.Initialize(\"MICROSOFT\")\n</pre> import opengeo as og  # Initialize with Microsoft Planetary Computer og.Initialize(\"MICROSOFT\") In\u00a0[\u00a0]: Copied! <pre>roi = og.Geometry.Rectangle(-65, -5, -60, 0)\nprint(\"ROI:\", roi)\n</pre> roi = og.Geometry.Rectangle(-65, -5, -60, 0) print(\"ROI:\", roi) In\u00a0[\u00a0]: Copied! <pre>modis_col = og.ImageCollection(\"modis-09ga-061\") \\\n    .filterDate(\"2023-01-01\", \"2023-01-10\") \\\n    .filterBounds(roi) \\\n    .select([\"sur_refl_b01\", \"sur_refl_b02\"]) # Band 1: Red, Band 2: NIR\n\nprint(f\"Images found: {modis_col.size()}\")\n</pre> modis_col = og.ImageCollection(\"modis-09ga-061\") \\     .filterDate(\"2023-01-01\", \"2023-01-10\") \\     .filterBounds(roi) \\     .select([\"sur_refl_b01\", \"sur_refl_b02\"]) # Band 1: Red, Band 2: NIR  print(f\"Images found: {modis_col.size()}\") In\u00a0[\u00a0]: Copied! <pre># Create median composite\nmodis_image = modis_col.median(epsg=3857)\n\nndvi = modis_image.normalizedDifference([\"sur_refl_b02\", \"sur_refl_b01\"]).rename(\"NDVI\")\n\nMap = og.Map()\nMap.addLayer(ndvi, {'min': 0, 'max': 0.8, 'palette': 'red,yellow,green'}, \"MODIS NDVI\")\nMap.centerObject(roi, zoom=5)\nMap\n</pre> # Create median composite modis_image = modis_col.median(epsg=3857)  ndvi = modis_image.normalizedDifference([\"sur_refl_b02\", \"sur_refl_b01\"]).rename(\"NDVI\")  Map = og.Map() Map.addLayer(ndvi, {'min': 0, 'max': 0.8, 'palette': 'red,yellow,green'}, \"MODIS NDVI\") Map.centerObject(roi, zoom=5) Map"},{"location":"examples/modis_analysis_nasa/#modis-surface-reflectance-with-opengeo-planetary-computer","title":"MODIS Surface Reflectance with OpenGeo (Planetary Computer)\u00b6","text":"<p>This notebook demonstrates how to access MODIS data using the <code>opengeo</code> package with the Microsoft Planetary Computer STAC API, which provides a highly efficient and well-indexed version of the NASA data.</p>"},{"location":"examples/modis_analysis_nasa/#1-initialize-opengeo","title":"1. Initialize OpenGeo\u00b6","text":""},{"location":"examples/modis_analysis_nasa/#2-define-roi","title":"2. Define ROI\u00b6","text":"<p>Define a region over the Amazon Rainforest.</p>"},{"location":"examples/modis_analysis_nasa/#3-load-modis-collection","title":"3. Load MODIS Collection\u00b6","text":"<p>Using <code>modis-09ga-061</code> on Planetary Computer. The bands on MS PC are usually named <code>sur_refl_b01</code>, etc.</p>"},{"location":"examples/modis_analysis_nasa/#4-calculate-ndvi","title":"4. Calculate NDVI\u00b6","text":"<p>We use Dask for efficient computation.</p>"},{"location":"examples/sar_analysis_umbra_capella/","title":"Umbra and Capella SAR Analysis with OpenGeo","text":"In\u00a0[1]: Copied! <pre>import opengeo as og\n\n# Initialize Umbra STAC (Canopy V2)\nog.Initialize(\"UMBRA\")\n</pre> import opengeo as og  # Initialize Umbra STAC (Canopy V2) og.Initialize(\"UMBRA\") <pre>C:\\Users\\pulak\\anaconda3\\envs\\maps\\Lib\\site-packages\\pyproj\\network.py:59: UserWarning: pyproj unable to set PROJ database path.\n  _set_context_ca_bundle_path(ca_bundle_path)\n</pre> <pre>OpenGeo initialized with STAC API: https://api.canopy.umbra.space/v2/stac/\n</pre> In\u00a0[2]: Copied! <pre>try:\n    umbra_col = og.ImageCollection(\"umbra-sar-data\") \\\n        .filterDate(\"2023-01-01\", \"2023-12-31\")\n    print(f\"Umbra images found: {umbra_col.size()}\")\nexcept Exception as e:\n    print(\"Could not query Umbra (check API availability or collection ID):\", e)\n</pre> try:     umbra_col = og.ImageCollection(\"umbra-sar-data\") \\         .filterDate(\"2023-01-01\", \"2023-12-31\")     print(f\"Umbra images found: {umbra_col.size()}\") except Exception as e:     print(\"Could not query Umbra (check API availability or collection ID):\", e) <pre>Could not query Umbra (check API availability or collection ID): {\"message\":\"Unauthorized\"}\n</pre> In\u00a0[3]: Copied! <pre>og.Initialize(\"CAPELLA\")\n# Search for a common Capella collection\ntry:\n    capella_col = og.ImageCollection(\"capella-gec\")\n    print(f\"Capella images found: {capella_col.size()}\")\nexcept Exception as e:\n    print(\"Capella query failed:\", e)\n</pre> og.Initialize(\"CAPELLA\") # Search for a common Capella collection try:     capella_col = og.ImageCollection(\"capella-gec\")     print(f\"Capella images found: {capella_col.size()}\") except Exception as e:     print(\"Capella query failed:\", e) <pre>OpenGeo initialized with STAC API: https://api.capellaspace.com/stac\n</pre> <pre>Capella query failed: {\"message\":\"Missing Authentication Token\"}\n</pre>"},{"location":"examples/sar_analysis_umbra_capella/#umbra-and-capella-sar-analysis-with-opengeo","title":"Umbra and Capella SAR Analysis with OpenGeo\u00b6","text":"<p>This notebook demonstrates how to access Umbra and Capella Synthetic Aperture Radar (SAR) data.</p>"},{"location":"examples/sar_analysis_umbra_capella/#1-initialize-umbra","title":"1. Initialize Umbra\u00b6","text":""},{"location":"examples/sar_analysis_umbra_capella/#2-load-umbra-sar-collection","title":"2. Load Umbra SAR Collection\u00b6","text":"<p>Note: Umbra items are often specialized. We'll search for recently created items.</p>"},{"location":"examples/sar_analysis_umbra_capella/#3-capella-initialize","title":"3. Capella Initialize\u00b6","text":""},{"location":"examples/sentinel2_analysis_element84/","title":"Sentinel-2 Analysis with OpenGeo (Element84)","text":"In\u00a0[\u00a0]: Copied! <pre>import opengeo as og\n\n# Initialize with Element84 Earth Search\nog.Initialize(\"https://earth-search.aws.element84.com/v1\")\n</pre> import opengeo as og  # Initialize with Element84 Earth Search og.Initialize(\"https://earth-search.aws.element84.com/v1\") In\u00a0[\u00a0]: Copied! <pre>roi = og.Geometry.Rectangle(-112.15, 36.05, -112.05, 36.15)\nprint(\"ROI:\", roi)\n</pre> roi = og.Geometry.Rectangle(-112.15, 36.05, -112.05, 36.15) print(\"ROI:\", roi) In\u00a0[\u00a0]: Copied! <pre>s2_col = og.ImageCollection(\"sentinel-2-c1-l2a\") \\\n    .filterDate(\"2023-05-01\", \"2023-05-31\") \\\n    .filterBounds(roi) \\\n    .select([\"red\", \"green\", \"blue\", \"nir\"])\n\nprint(f\"Images found: {s2_col.size()}\")\n</pre> s2_col = og.ImageCollection(\"sentinel-2-c1-l2a\") \\     .filterDate(\"2023-05-01\", \"2023-05-31\") \\     .filterBounds(roi) \\     .select([\"red\", \"green\", \"blue\", \"nir\"])  print(f\"Images found: {s2_col.size()}\") In\u00a0[\u00a0]: Copied! <pre># Specify EPSG to avoid CRS ambiguity\ns2_image = s2_col.median(epsg=32612)\n\nMap = og.Map()\nMap.addLayer(s2_image, {'bands': ['red', 'green', 'blue'], 'min': 0, 'max': 3000}, \"Sentinel-2 RGB\")\nMap.centerObject(roi, zoom=12)\nMap\n</pre> # Specify EPSG to avoid CRS ambiguity s2_image = s2_col.median(epsg=32612)  Map = og.Map() Map.addLayer(s2_image, {'bands': ['red', 'green', 'blue'], 'min': 0, 'max': 3000}, \"Sentinel-2 RGB\") Map.centerObject(roi, zoom=12) Map In\u00a0[\u00a0]: Copied! <pre>ndvi = s2_image.normalizedDifference([\"nir\", \"red\"]).rename(\"NDVI\")\nMap.addLayer(ndvi, {'min': 0, 'max': 0.8, 'palette': 'red,yellow,green'}, \"Sentinel-2 NDVI\")\nMap\n</pre> ndvi = s2_image.normalizedDifference([\"nir\", \"red\"]).rename(\"NDVI\") Map.addLayer(ndvi, {'min': 0, 'max': 0.8, 'palette': 'red,yellow,green'}, \"Sentinel-2 NDVI\") Map"},{"location":"examples/sentinel2_analysis_element84/#sentinel-2-analysis-with-opengeo-element84","title":"Sentinel-2 Analysis with OpenGeo (Element84)\u00b6","text":"<p>This notebook demonstrates how to perform Sentinel-2 imagery analysis using the <code>opengeo</code> package with the Element84 Earth Search STAC API.</p>"},{"location":"examples/sentinel2_analysis_element84/#1-initialize-opengeo","title":"1. Initialize OpenGeo\u00b6","text":""},{"location":"examples/sentinel2_analysis_element84/#2-define-roi","title":"2. Define ROI\u00b6","text":"<p>Define a region over the Grand Canyon.</p>"},{"location":"examples/sentinel2_analysis_element84/#3-load-sentinel-2-collection","title":"3. Load Sentinel-2 Collection\u00b6","text":"<p>Sentinel-2 L2A collection on Earth Search is <code>sentinel-2-c1-l2a</code>.</p>"},{"location":"examples/sentinel2_analysis_element84/#4-true-color-visualization","title":"4. True Color Visualization\u00b6","text":"<p>Combine bands for RGB visualization. We specify <code>epsg=32612</code> (UTM Zone 12N) to ensure a consistent coordinate system.</p>"},{"location":"examples/sentinel2_analysis_element84/#5-calculate-ndvi","title":"5. Calculate NDVI\u00b6","text":""}]}